原型模式：用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象
具体实现： 实现Cloneable接口 重写clone方法

迭代器模式：它提供一种方法访问一个容器对象中各个元素，而又不需暴露该对象的内部细节。
具体实现： Jdk中实现了Iterator接口的容器类

组合模式：将对象组合成树形结构以表示“部分-整体”的层次结构，使得用户对单个对象和组合对象的使用具有一致性
具体实现：
1.抽象通用属性类作为所有角色的基类
2.树叶类作为最小单元类,继承通用类只做业务
3.树枝类继承通用属性类,内部维护下层的树枝类和叶子类的信息(List<>)，并且提供添加和删除下级枝叶节点

门面模式：要求一个子系统的外部与其内部的通信必须通过一个统一的对象进行。门面模式提供一个高层次的接口，使得子系统更易于使用
具体实现：
门面角色：客户端可以调用这个角色的方法。此角色知晓子系统的所有功能和责任。一般情况下，本角色会将所有从客户端发来的请求委派到相
        应的子系统去，也就说该角色没有实际的业务逻辑，只是一个委托类
子系统角色：可以同时有一个或者多个子系统。每一个子系统都不是一个单独的类，而是一个类的集合。子系统并不知道门面的存在。对于子系统
          而言，门面仅仅是另外一个客户端而已,子系统不变还是做自己的事

备忘录模式：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态
具体实现：
Originator发起人角色：记录当前时刻装备,负责创建和恢复备忘录数据
Memento备忘录角色：负责存储发起人角色内部某一时刻的状态，在需要的时候给发起人角色还原
Caretaker备忘录管理员角色： 对备忘录进行管理、保存和提供备忘录。

访问者模式：封装一些作用于某种数据结构中的各元素的操作，它可以在不改变数据结构的前提下定义作用于这些元素的新的操作

状态模式：当一个对象内在状态改变时允许其改变行为，这个对象看起来像改变了其类
具体实现：抽象基类State内含上下文类Context(内部维护当前状态State和其包含的方法)  State子类继承State重写方法,
        执行本状态方法的逻辑,其余状态执行逻辑则通过Context切换当前状态并执行相应状态对应的方法

解释器模式： 给定一门语言，定义它的文法的一种表示，并定义一个解释器，该解释器使用该表示来解释语言中的句子

享元模式：使用共享对象可有效地支持大量的细粒度的对象
具体实现：各种池技术，类似线程池  重点是factory内部维护Map<String,Resources>

桥梁模式：将抽象和实现解耦，使得两者可以独立地变化
具体实现：实现类角色专注做具体事，抽象类角色持有实现类角色引用并调用其方法    抽象角色引用实现角色，或者说抽象角色的部分实现是由实现角色完成的